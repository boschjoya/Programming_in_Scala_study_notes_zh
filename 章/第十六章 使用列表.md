### 第十六章 使用列表

#### 16.1
```scala
val 水果 = List("苹果", "桔子", "梨")
val 数字 = List(1, 2, 3, 4)
val 方阵3 =
  List(
    List(1, 0, 0)
    List(0, 1, 0)
    List(0, 0, 1)
  )
val 空 = List()
```

#### 16.2 List类型
```scala
val 水果: List[String] = List("苹果", "桔子", "梨")
val 数字: List[Int] = List(1, 2, 3, 4)
val 方阵3: List[List[Int]] =
  List(
    List(1, 0, 0)
    List(0, 1, 0)
    List(0, 0, 1)
  )
val 空: List[Nothing] = List()
```
空列表可以是任何类型:
```scala
val 某: List[String] = List()
```

#### 16.3 构造列表
`Nil`为空表, `::`向列表头部追加元素
```scala
val 水果 = "苹果" :: ("桔子" :: ("梨" :: Nil))
val 数字 = 1 :: (2 :: (3 :: (4 :: Nil)))
// 方阵3 太长略去
val 空 = Nil
```
因为以:结束, ::是右结合的. 因此可以省去():
```scala
val 数字 = 1 :: 2 :: 3 :: 4 :: Nil
```

#### 16.4 基本操作
```
scala> Nil.head
java.util.NoSuchElementException: head of empty list
```
插入排序算法:
```scala
def 插入(值: Int, 列表: List[Int]): List[Int] = {
  if (列表.isEmpty || 值 <= 列表.head) 值 :: 列表
  else 列表.head :: 插入(值, 列表.tail)
}

def 插入排序(列表: List[Int]): List[Int] = {  // 原代码中无 {}, 运行出错
  if (列表.isEmpty) Nil
  else 插入(列表.head, 插入排序(列表.tail))
}
```

#### 16.5 列表模式
```
scala> val List(a, b, c) = 水果
a: String = 苹果
b: String = 桔子
c: String = 梨
```
下面应该与[之前问题原因](https://github.com/program-in-chinese/Programming_in_Scala_study_notes_zh#%E5%91%BD%E5%90%8D%E9%97%AE%E9%A2%98)相同. 下面用_开头规避此问题.
```
scala> val a :: b :: 余下 = 水果
<console>:14: error: not found: value 余下
       val a :: b :: 余下 = 水果
                     ^
```
用模式重写插入排序:
```scala
def 插入(值: Int, 列表: List[Int]): List[Int] = 列表 match {
  case List() => List(值)
  case _头 :: _余下 =>
    if (值 <= _头) 值 :: 列表
    else _头 :: 插入(值, _余下)
}

def 插入排序(列表: List[Int]): List[Int] = 列表 match {
  case List() => List()
  case _值 :: _余下 => 插入(_值, 插入排序(_余下))
}
```

#### 16.6 一阶函数
合并两个列表
```
scala> List(1, 2) ::: List(3, 4, 5)
res7: List[Int] = List(1, 2, 3, 4, 5)
```
分而治之 -- 模式匹配实现合并
```scala
def 追加[T](表1: List[T], 表2: List[T]): List[T] =
  表1 match {
    case List() => 表2
    case _头 :: _表1余下 => _头 :: 追加(_表1余下, 表2)
  }
```
长度
```
scala> List(1, 2, 3).length
res9: Int = 3
```

**暂跳过**

#### 16.7 高阶函数

映射

map
```
scala> List(1,2,3) map (_ + 1)
res10: List[Int] = List(2, 3, 4)

scala> val 词 = List("小", "呀么", "小二郎", "呀")
词: List[String] = List(小, 呀么, 小二郎, 呀)

scala> 词 map (_.length)
res11: List[Int] = List(1, 2, 3, 1)

scala> 词 map (_.toList.reverse.mkString)
res12: List[String] = List(小, 么呀, 郎二小, 呀)
```
flatMap, 参数为一个返回列表的函数, 将所有返回的列表合并. 对比:
```
scala> 词 map (_.toList)
res13: List[List[Char]] = List(List(小), List(呀, 么), List(小, 二, 郎), List(呀))

scala> 词 flatMap (_.toList)
res14: List[Char] = List(小, 呀, 么, 小, 二, 郎, 呀)
```
1<=j<i<5的组合:
```
scala> List.range(1, 5) flatMap (
     |   i => List.range(1, i) map (j => (i, j))
     | )
res17: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1), (4,2), (4,3))
```
等价于
```scala
for (i <- List.range(1, 5); j <- List.range(1, i)) yield (i, j)
```

**待续**